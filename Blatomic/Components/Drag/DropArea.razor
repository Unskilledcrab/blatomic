@typeparam TData

@implements IAsyncDisposable
@inject ElementService ElementService

<div @ref="container" class="relative" ondragover="event.preventDefault();"
    ondragstart="event.dataTransfer.setData('', event.target.id);" @ondragenter="HandleDragEnter">

    <CascadingValue Value="this">
        @if (ChildContent is not null)
        {
            @ChildContent(BoundItems)
        }
    </CascadingValue>
    @if (isShowingDrop)
    {
        <div class="absolute z-10 flex justify-center items-center inset-0">
            @if (canDrop)
            {
                @CanDropTemplate
            }
            else
            {
                @CannotDropTemplate
            }
        </div>
        <div class="absolute z-20 flex justify-center items-center inset-0 bg-gray-300/25 @dropClass"
             @ondragleave="HandleDragLeave" @ondrop="HandleDrop">
        </div>
    }
</div>

@code {
    private ElementReference container;
    private string dropClass = string.Empty;
    private bool isShowingDrop = false;
    private bool canDrop = false;

    [CascadingParameter] public DragContext<TData>? Context { get; set; }

    private List<TData> BoundItems
    {
        get => Items;
        set
        {
            Items = value;
            ItemsChanged.InvokeAsync(value);
        }
    }
    [Parameter] public List<TData> Items { get; set; } = new();
    [Parameter] public EventCallback<List<TData>> ItemsChanged { get; set; }

    [Parameter] public Func<DragArgs<TData>, Task<bool>> CanDropAsync { get; set; } = (dropItem) => Task.FromResult(true);
    [Parameter] public Func<DragArgs<TData>, Task> OnDragEnterAsync { get; set; } = (dropItem) => Task.CompletedTask;
    [Parameter] public Func<DragArgs<TData>, Task> OnDragLeaveAsync { get; set; } = (dropItem) => Task.CompletedTask;
    [Parameter] public Func<DragArgs<TData>, Task> BeforeDropAsync { get; set; } = (dropItem) => Task.CompletedTask;
    [Parameter] public Func<DragArgs<TData>, Task> OnDropAsync { get; set; } = (dropItem) => Task.CompletedTask;
    [Parameter] public string DropClass { get; set; } = "outline-2 outline-dashed animate-pulse";

    [Parameter] public RenderFragment<List<TData>>? ChildContent { get; set; }
    [Parameter] public RenderFragment? CanDropTemplate { get; set; } = @Plus.StandardPlusOutline;
    [Parameter] public RenderFragment? CannotDropTemplate { get; set; } = @Ban.StandardBanSolid;

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);

        if (firstRender)
        {
            Context?.DropAreas.Add(this);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await ElementService.Import();
        await base.OnAfterRenderAsync(firstRender);
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        await ElementService.DisposeAsync();
    }

    public async Task<BoundingClientRect> GetBoundingClientRect()
    {
        return await ElementService.GetBoundingClientRect(container);
    }

    public void RemoveDragItem(TData dragItem)
    {
        if (dragItem is not null)
        {
            if (BoundItems.Remove(dragItem))
            {
                StateHasChanged();
            }
        }
    }
    public void AddDragItem(TData dragItem)
    {
        if (dragItem is not null)
        {
            BoundItems.Remove(dragItem);
        }
    }

    public void ShowDroppableStyle(bool canDrop)
    {
        this.canDrop = canDrop;
        isShowingDrop = true;
        dropClass = DropClass;
        StateHasChanged();
    }

    public void HideDroppableStyle()
    {
        canDrop = false;
        isShowingDrop = false;
        dropClass = string.Empty;
        StateHasChanged();
    }

    private async Task HandleDragEnter(DragEventArgs e)
    {
        if (Context == null || Context.DragData == null)
        {
            return;
        }

        var args = e.Create(Context.DragData);
        await OnDragEnterAsync(args);

        if (await CanDropAsync(args))
        {
            ShowDroppableStyle(true);
        }
        else
        {
            ShowDroppableStyle(false);
        }
    }
    private async Task HandleDragLeave(DragEventArgs e)
    {
        if (Context == null || Context.DragData == null)
        {
            return;
        }

        var args = e.Create(Context.DragData);
        await OnDragLeaveAsync(e.Create(Context.DragData));
        HideDroppableStyle();
    }
    private async Task HandleDrop(DragEventArgs e)
    {
        if (Context == null || Context.DragData == null)
        {
            return;
        }

        var args = e.Create(Context.DragData);
        await DropAsync(args);
    }

    public async Task DropAsync(DragArgs<TData> args)
    {
        if (await CanDropAsync(args))
        {
            await BeforeDropAsync(args);
            if (args.Data != null)
            {
                BoundItems.Add(args.Data);                
            }
            Context?.DragItem?.OnDragComplete();
            await OnDropAsync(args);
        }
        HideDroppableStyle();
    }
}