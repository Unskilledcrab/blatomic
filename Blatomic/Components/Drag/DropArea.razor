@typeparam TData

@implements IAsyncDisposable
@inject ElementService ElementService

<div @ref="container" class="b-relative" ondragover="event.preventDefault();"
    ondragstart="event.dataTransfer.setData('', event.target.id);" @ondragenter="HandleDragEnter">

    <CascadingValue Value="this">
        @if (ChildContent is not null)
        {
            @ChildContent(BoundItems)
        }
    </CascadingValue>
    @if (isShowingDrop)
    {
        <div class="b-absolute b-z-10 b-flex b-justify-center b-items-center b-inset-0">
            @if (canDrop)
            {
                @CanDropTemplate
            }
            else
            {
                @CannotDropTemplate
            }
        </div>
        <div class="b-absolute b-z-20 b-inset-0 @DropBorderClass"
             @ondragleave="HandleDragLeave" @ondrop="HandleDrop">
        </div>
    }
</div>

@code {
    private ElementReference container;
    private string dropBorderClass = string.Empty;
    private bool isShowingDrop = false;
    private bool canDrop = false;

    [CascadingParameter] public DragContext<TData>? Context { get; set; }

    [Parameter] public string DropBorderClass { get; set; } = "b-outline-2 b-outline-dashed b-animate-pulse b-bg-gray-300/25";
    [Parameter] public bool ShowCantDrop { get; set; } = true;
    private List<TData> BoundItems
    {
        get => Items;
        set
        {
            Items = value;
            ItemsChanged.InvokeAsync(value);
        }
    }
    [Parameter] public List<TData> Items { get; set; } = new();
    [Parameter] public EventCallback<List<TData>> ItemsChanged { get; set; }

    [Parameter] public Func<DragArgs<TData>, Task<bool>> CanDropAsync { get; set; } = (dropItem) => Task.FromResult(true);
    [Parameter] public Func<DragArgs<TData>, Task> OnDragEnterAsync { get; set; } = (dropItem) => Task.CompletedTask;
    [Parameter] public Func<DragArgs<TData>, Task> OnDragLeaveAsync { get; set; } = (dropItem) => Task.CompletedTask;

    /// <summary>
    /// Return if you could like the item to be added to the internal list. Default true
    /// </summary>
    [Parameter] public Func<DragArgs<TData>, Task<bool>> BeforeDropAsync { get; set; } = (dropItem) => Task.FromResult(true);
    [Parameter] public Func<DragArgs<TData>, Task> OnDropCompleteAsync { get; set; } = (dropItem) => Task.CompletedTask;

    [Parameter] public RenderFragment<List<TData>>? ChildContent { get; set; }
    [Parameter] public RenderFragment? CanDropTemplate { get; set; } = @Plus.StandardPlusOutline;
    [Parameter] public RenderFragment? CannotDropTemplate { get; set; } = @Ban.StandardBanSolid;

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);
        
        if (firstRender)
        {
            Context?.DropAreas.Add(this);
        }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        await ElementService.DisposeAsync();
    }

    public async Task<BoundingClientRect> GetBoundingClientRect()
    {
        return await ElementService.GetBoundingClientRect(container);
    }

    public void RemoveDragItem(TData dragItem)
    {
        if (dragItem is not null)
        {
            if (BoundItems.Remove(dragItem))
            {
                StateHasChanged();
            }
        }
    }

    public void ShowDroppableStyle(bool canDrop)
    {
        if (!ShowCantDrop && !canDrop)
        {
            return;
        }

        this.canDrop = canDrop;
        isShowingDrop = true;
        dropBorderClass = DropBorderClass;
    }

    public void HideDroppableStyle()
    {
        canDrop = false;
        isShowingDrop = false;
        dropBorderClass = string.Empty;
    }

    private async Task HandleDragEnter(DragEventArgs e)
    {
        if (Context == null || Context.DragData == null)
        {
            return;
        }

        var args = e.Create(Context.DragData);
        await OnDragEnterAsync(args);
    }
    private async Task HandleDragLeave(DragEventArgs e)
    {
        if (Context == null || Context.DragData == null)
        {
            return;
        }

        var args = e.Create(Context.DragData);
        await OnDragLeaveAsync(e.Create(Context.DragData));
    }
    private async Task HandleDrop(DragEventArgs e)
    {
        if (Context == null || Context.DragData == null)
        {
            return;
        }

        var args = e.Create(Context.DragData);
        await DropAsync(args);
    }

    public async Task DropAsync(DragArgs<TData> args)
    {
        if (await CanDropAsync(args))
        {
            if (args.Data != null && await BeforeDropAsync(args))
            {
                BoundItems.Add(args.Data);                
            }
            Context?.DragItem?.OnDragToDropZoneComplete();
            await OnDropCompleteAsync(args);
        }
        HideDroppableStyle();
    }
}